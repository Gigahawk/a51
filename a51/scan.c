#include "common/global.h"
#pragma hdrstop
#include "a51.h"
#include "a_tab.h"

#define MAX_INCLUDE_PATH_SIZE   512
#define MAX_COND_DEPTH          32

//////////////////////////////////////////////////////////////////////////
// Global variables

TFileData    * IncludeTop = NULL;  // top of include stack list
UCHAR _DSPTR * LastLineStr = NULL; // pointer to the start of the
                                   // last line being processed
int            InclNest;           // include file nesting

BOOL           bLstGen;            // last line was generated by somebody,
                                   // so we need not copy it to the listing
                                   // file.

LIST_ENTRY     FileNames;          // list of all file names used

//////////////////////////////////////////////////////////////////////////
// Local variables

static char  IncludePath[MAX_INCLUDE_PATH_SIZE] = ""; // must be initialized
                                                      // before Scan_Init()  
static int   LastLex;
static char  BraceBuf[FILENAME_MAX+1]; // a buffer for GetToClosingBrace

// variables for line buffering
static FILE   * File;        // current input file
static UCHAR  LineBuf[LINE_BUF_SIZE];   // current input line buffer
static UINT   CurPos;        // position in LineBuf
static UINT   BufUsed;       // data length stored in LineBuf

static const char szOpenMode[] = "rb";

#define COND_IF    0
#define COND_ELSE  1
#define COND_ENDIF 2
 
typedef struct TCond
{
  UINT mode  : 1;  // skip = FALSE 
  UINT expr  : 1;    
  UINT weare : 4;
} TCond;

static TCond CondStack[MAX_COND_DEPTH];
static TCond CurCond; // = { TRUE }
static int   CondSP;  // = -1

// override = TRUE means that although we are in skip mode we must parse
//  the rest of the current line (for processing conditional operators)
//  override is always cleared at each new line.
static BOOL  override; // = FALSE

//////////////////////////////////////////////////////////////////////////
// Local functions

static TFileName * AddFileName ( const char * fileName )
{
  TFileName * p;
  int len;

  // Check if we already have this name
  for( p = (TFileName *)FileNames.Flink;
       !EndOfList( &FileNames, p );
       p = (TFileName *)p->link.Flink )
  {
    if (_stricmp( fileName, p->name ) == 0)
      return p;
  }

  // Allocate a new name
  //
  len = strlen( fileName ) + 1;
  p = xmalloc( offsetof( TFileName, name ) + len );
  memcpy( p->name, fileName, len );
  InsertTailList( &FileNames, &p->link );  // add it to the list

  return p;
};

//--------------------------------------------------------------------------
// Name         FindAndOpenFile
//
// Description  Search the include path and the current directory for the
//              file. If standart == TRUE scans the include path first.
//              (#include <xx> semantics)
//--------------------------------------------------------------------------
static FILE * FindAndOpenFile ( const char * fileName, BOOL standart )
{
  FILE * f;
  int    nameLen = strlen( fileName );
  char * cur;

  if (!standart)        // will check current directory first
  {
//    TRACE1( "Opening '%s'...", fileName );
    if (f = fopen( fileName, szOpenMode ))
    {
//      TRACE0( "OK.\n" );
      return f;
    }
//    TRACE0( "Failed!\n" );
  }

  // now scan the include path
  for( cur = IncludePath; *cur; )
  {
    char * endPtr;      // points to the semicolon
    char pathBuf[FILENAME_MAX+1];
    int  curLen;

    if (endPtr = strchr( cur, ';' ))
      *endPtr = 0;      // simulate zero termination

    curLen = strlen( cur );
    if (curLen + nameLen < sizeof( pathBuf ) - 1)
    {
      memcpy( pathBuf, cur, curLen + 1 );
      if (curLen && pathBuf[curLen - 1] != '\\')
        strcat( pathBuf, "\\" );
      strcat( pathBuf, fileName );
                      
//      TRACE1( "Opening '%s'...", pathBuf );
      if (f = fopen( pathBuf, szOpenMode ))
      {
//        TRACE0( "OK.\n" );
        return f;
      }
//      TRACE0( "Failed!\n" );
    }

    if (endPtr)
    {
      *endPtr = ';';
      cur = endPtr + 1;
    }
    else
      cur += curLen;    // will point to 0
  }

  if (standart)
  {
//    TRACE1( "Opening '%s'...", fileName );
    if (f = fopen( fileName, szOpenMode ))
    {
//      TRACE0( "OK.\n" );
      return f;
    }
//    TRACE0( "Failed!\n" );
  }

//  TRACE1( "**Error: Could not find '%s'\n", fileName );
  return NULL;
};


//--------------------------------------------------------------------------
// Name         FillBuffer
//
// Description  Fill the buffer from BufUsed on...
//              Increase BufUsed with the bytes read
//              On read error generates fatal error
//--------------------------------------------------------------------------
static void FillBuffer ( void )
{
  UINT bRead;

  bRead = fread( LineBuf + BufUsed, 1, LINE_BUF_SIZE - BufUsed, File );

  if (bRead == 0 && ferror( File ))
    PrintFatal( FATAL_READ_FILE );

  BufUsed += bRead;
};

//--------------------------------------------------------------------------
// Name         RLine_Reset
//
// Description  Start processing a file. seeks to BOF and sets the static
//              variables.
//--------------------------------------------------------------------------
void RLine_Reset ( TFileData * fData )
{
  File    = fData->File;
  CurPos  =
  BufUsed = 0;

  fseek( File, 0, SEEK_SET );
  FillBuffer();
};

void RLine_UnSet ( TFileData * fData )
{
  fData->CurPos = CurPos;
  fData->BufUsed = BufUsed;
  memcpy( fData->LineBuf + CurPos, LineBuf + CurPos, BufUsed - CurPos );
};

void RLine_Set ( TFileData * fData )
{
  File    = fData->File;
  CurPos  = fData->CurPos;
  BufUsed = fData->BufUsed;
  memcpy( LineBuf + CurPos, fData->LineBuf + CurPos, BufUsed - CurPos );
};

//--------------------------------------------------------------------------
// Name         AppendLine
//
// Description  Moves the data from _lineStart_ to the start of buffer and
//              fills the emptied space.
//--------------------------------------------------------------------------
static void AppendLine ( UCHAR _DSPTR * lineStart )
{
  BOOL eof = BufUsed < LINE_BUF_SIZE;

  CurPos  =
  BufUsed = LINE_BUF_SIZE - (lineStart - LineBuf);
  memcpy( LineBuf, lineStart, BufUsed );

  if (!eof)     // on eof do not try to read 
    FillBuffer();
};

//--------------------------------------------------------------------------
// Name         ReadLine
//
// Description  Return a pointer to the next line (ASCIIZ)
//              NULL on EOF
//--------------------------------------------------------------------------
static UCHAR _DSPTR * ReadLine ( void )
{
  UCHAR _DSPTR * pCR;
  UCHAR _DSPTR * res;

scanCR:
  if (CurPos == BufUsed && BufUsed < LINE_BUF_SIZE)        // check for EOF
    return NULL;

  res = LineBuf + CurPos;

  // NOTE: In BC31 memchr( ..,.., 0 ) returns != NULL, so check count
  if (BufUsed != CurPos &&
      (pCR = (char _DSPTR *)memchr( LineBuf + CurPos, '\n', BufUsed - CurPos ))
       != NULL)
  {
    *pCR = 0;                   // mark EOL
    CurPos = pCR - LineBuf + 1; // set CurPos after EOL

    return res;
  }
  else
  {
    // if we have EOF without prior EOL
    if (BufUsed < LINE_BUF_SIZE)
    {
      LineBuf[BufUsed] = 0;     // put an EOL anyway
      CurPos = BufUsed;
      return res;
    }
    // check for a line longer than LINE_BUF_SIZE
    if (CurPos == 0)
    {
      PrintError( ERR_LINE_LONG );
      LineBuf[BufUsed-1] = 0;
      return res;
    }

    AppendLine( LineBuf + CurPos );
    CurPos = 0;
    goto scanCR;
  }
};


//////////////////////////////////////////////////////////////////////////
// Global functions

//--------------------------------------------------------------------------
// Name         AddToIncludePath
//
// Description  Adds a string to the include path buffer. If necessary appends
//              a ';'. (All strings are separated with ';'). Returns FALSE
//              if the buffer overflows. In that case adds nothing.
//--------------------------------------------------------------------------
BOOL AddToIncludePath ( const char * iPath )
{
  int curLen = strlen( IncludePath );
  int iLen = strlen( iPath );

    // check if would overflow the buffer (consider the ';')
  if (curLen + iLen >= MAX_INCLUDE_PATH_SIZE - 1)
    return FALSE;

  ASSERT( curLen == 0 || IncludePath[curLen - 1] == ';' );

  memcpy( IncludePath + curLen, iPath, iLen + 1 );

  // if necessary append ';'
  if (IncludePath[curLen + iLen - 1] != ';')
  {
    IncludePath[curLen + iLen] = ';';
    IncludePath[curLen + iLen + 1] = 0;
  }

  return TRUE;
};

BOOL Scan_Init ( void )
{
  MiniLex_Init();

  IncludeTop = NULL;
  InclNest   = -1;

  CurCond.mode = TRUE;
  CondSP = -1;
  override = FALSE;

  InitializeListHead( &FileNames );

  return TRUE;
};

void Scan_Done ( void )
{
  while (IncludeTop)
  {
    TFileData * p;

    if (IncludeTop->File)
      fclose( IncludeTop->File );
    p = IncludeTop->Prev;
    xfree( IncludeTop );
    IncludeTop = p;
  }

  // free all file names
  while (!IsListEmpty( &FileNames ))
  {
    TFileName * p = (TFileName *)RemoveTailList( &FileNames );
    xfree( p );
  }  

  MiniLex_Done();
};

//--------------------------------------------------------------------------
// Name         Scan_Reset
//
// Description  Reset the scanner between passes
//--------------------------------------------------------------------------
void Scan_Reset ( void )
{
  // close all nested includes (there should not be any!)
  while (IncludeTop->Prev)
  {
    TFileData * p;
//    TRACE1( "Closing '%s'\n", IncludeTop->pName->name );

    if (IncludeTop->File)
      fclose( IncludeTop->File );
    p = IncludeTop->Prev;
    xfree( IncludeTop );
    IncludeTop = p;
  }

  InclNest = 0;
  IncludeTop->CurLine = 0;
  RLine_Reset( IncludeTop );
  LastLex = LEX_EOL;
  bLstGen = TRUE;

  CurCond.mode = TRUE;
  CondSP = -1;
  override = FALSE;
};

static void IncludeAFile ( FILE * f, const char * aName )
{
  TFileData * pFile;

  pFile = xmalloc( sizeof( TFileData ) );
  pFile->pName = AddFileName( aName );
  pFile->File = f;
  pFile->CurLine = 0;
  pFile->Prev = IncludeTop;

  if (IncludeTop)
    RLine_UnSet( IncludeTop );

  IncludeTop = pFile;
  ++InclNest;
  RLine_Reset( IncludeTop );
};

void OpenInput ( const char * szFileName )
{
  FILE * f;

  if (!(f = fopen( szFileName, szOpenMode )))
    FatalError( "Error opening '%s': %s", szFileName, strerror( errno ) );

  IncludeAFile( f, szFileName );
  LastLex = LEX_EOL;
  bLstGen = TRUE;
};

static void OpenInclude ( const char * szFileName )
{
  FILE * f;

  if (!(f = FindAndOpenFile( szFileName, FALSE )))
    PrintFatal( FATAL_OPEN_INCLUDE, szFileName );

  IncludeAFile( f, szFileName );
  LastLex = LEX_EOL;
  bLstGen = TRUE;
};

//--------------------------------------------------------------------------
// Name         GetLex
//
// Description  This is the main lexical function.
//--------------------------------------------------------------------------
int GetLex ( void )
{
  for(;;)
  {
    if (LastLex == LEX_EOL)
    {
      if (bLstGen == FALSE)
        GenListingLine();

      bLstGen = FALSE;
      override = FALSE;
      while (++IncludeTop->CurLine, (LastLineStr = ReadLine()) == NULL)
      {
        TFileData * prev;
        --InclNest;
        if (prev = IncludeTop->Prev)
        {
          fclose( IncludeTop->File );
          xfree( IncludeTop );
          IncludeTop = prev;
          RLine_Set( IncludeTop );
        }
        else
        {
          if (CondSP > -1)
          {
            PrintError( ERR_OPEN_COND );
            CondSP = 0;
          }
          return LEX_EOF;
        }
      }
      CurCharPtr = LastLineStr;
    }
    LastLex = IdentGetLex( CurCond.mode | override );
    if ((CurCond.mode | override) == FALSE)
    {
      if (LastLex == LEX_IF || LastLex == LEX_ELSE || LastLex == LEX_ENDIF ||
          LastLex == LEX_IFDEF || LastLex == LEX_IFNDEF)
        override = TRUE;
      else
      {
        LastLex = LEX_EOL;
        continue;
      }
    }
    return LastLex;
  }
};

//--------------------------------------------------------------------------
// Name         GetToClosingBrace
//
// Description  Get any string up to a closing brace ')'.
//              Leave the brace for the parser to process. This function
//              is used to parse nonstandart expressions in braces
//              (like $INCLUDE, $DATE, $TITLE, etc...)
//              Stores the string ing BraceBuf
//--------------------------------------------------------------------------
void GetToClosingBrace ( void )
{
  char _DSPTR * p;

  // find the closing brace
  if (p = (char _DSPTR *)strchr( (char *)CurCharPtr, ')' ))
  {
    int len;
    if ((len = p - (char *)CurCharPtr) > sizeof( BraceBuf ) - 1)
      len = sizeof( BraceBuf ) - 1;
    ((char *)memcpy( BraceBuf, CurCharPtr, len ))[len] = 0;

    CurCharPtr = (BYTE _DSPTR *)p;
  }
  else
  {
    //no ')' =>  The parser will signal an error
    BraceBuf[0] = 0;
  }
};

//--------------------------------------------------------------------------
// Name         GetIncludeName
//
// Description  Get the include name and store it in BraceBuf
//              Later _Include_ will open it
//--------------------------------------------------------------------------
void GetIncludeName ( void )
{
  GetToClosingBrace();
};

//--------------------------------------------------------------------------
// Name         Include
//
// Description  Include the file name that was stored by GetIncludeName
//--------------------------------------------------------------------------
void Include ( void )
{
  OpenInclude( BraceBuf );
};

void DoIf ( BOOL expr )
{
  if (CondSP == _countof( CondStack ) - 1)
    PrintFatal( FATAL_MANY_NEST_COND );
  else
  {
    CondStack[++CondSP] = CurCond;

    CurCond.expr = expr;
    CurCond.mode = CondStack[CondSP].mode & CurCond.expr;
    CurCond.weare = COND_IF;
  }
};

void DoElse ( void )
{
  if (CondSP < 0)
    PrintError( ERR_INV_ELSE );
  else
  {
    CurCond.mode = CondStack[CondSP].mode & ~CurCond.expr;
    CurCond.weare = COND_ELSE;
  }
};

void DoEndif ( void )
{
  if (CondSP < 0)
    PrintError( ERR_INV_ENDIF );
  else
    CurCond = CondStack[CondSP--];
};

